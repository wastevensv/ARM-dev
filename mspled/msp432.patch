diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 727e4f2..bd49c5a 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -33,6 +33,7 @@ NOR_DRIVERS = \
 	%D%/lpcspifi.c \
 	%D%/mdr.c \
 	%D%/mrvlqspi.c \
+	%D%/msp432p4.c \
 	%D%/niietcm4.c \
 	%D%/non_cfi.c \
 	%D%/nrf51.c \
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index 56a5cb2..440db02 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -46,6 +46,7 @@ extern struct flash_driver lpc2900_flash;
 extern struct flash_driver lpcspifi_flash;
 extern struct flash_driver mdr_flash;
 extern struct flash_driver mrvlqspi_flash;
+extern struct flash_driver msp432p4_flash;
 extern struct flash_driver niietcm4_flash;
 extern struct flash_driver nrf51_flash;
 extern struct flash_driver numicro_flash;
@@ -98,6 +99,7 @@ static struct flash_driver *flash_drivers[] = {
 	&lpcspifi_flash,
 	&mdr_flash,
 	&mrvlqspi_flash,
+	&msp432p4_flash,
 	&niietcm4_flash,
 	&nrf51_flash,
 	&numicro_flash,
diff --git a/src/flash/nor/msp432p4.c b/src/flash/nor/msp432p4.c
new file mode 100644
index 0000000..cf940f2
--- /dev/null
+++ b/src/flash/nor/msp432p4.c
@@ -0,0 +1,532 @@
+/***************************************************************************
+ *   Copyright (C) 2014 by Vlad Ungureanu                                  *
+ *   vvu@vdev.ro                                                           *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include "msp432p4.h"
+#include <helper/binarybuffer.h>
+#include <target/algorithm.h>
+#include <target/armv7m.h>
+#include <target/image.h>
+
+#define FLASH_FUNCTION			0x20000150
+#define FLASH_MASS_ERASE		0x01
+#define FLASH_SECTOR_ERASE		0x02
+#define FLASH_PROGRAM			0x04
+#define FLASH_INIT				0x08
+
+#define RETURN_CODE				0x20000154
+#define DEFAULT_CODE			0x00000DEF
+#define ENTRY_POINT				0x01000180
+
+#define SRC_ADDRESS				0x20000160
+#define DST_ADDRESS				0x20000164
+#define SRC_LENGTH				0x20000168
+
+#define ERASE_PARAMETER			0x2000016C
+#define ERASE_MAIN				0x01
+#define ERASE_INFO				0x02
+#define ERASE_MAIN_INFO			0x03
+
+#define SRC_START				0x20002000
+#define STC_MAX_LENGTH			4096
+
+#define FLASH_BUSY				0x00000001
+#define FLASH_SUCCESS			0x00000ACE
+#define FLASH_ERROR				0x0000DEAD
+#define FLASH_TIMEOUT_ERROR		0xDEAD0000
+#define FLASH_VERIFY_ERROR		0xDEADDEAD
+#define FLASH_WRONG_CMD			0x00000BAD
+#define FLASH_PWR_ERR			0x00DEAD00
+
+#define FLASH_SIZE_REG			0xE0043020
+#define CPU_TYPE				0xE000ED00
+#define DDDS_DEV_ID				0x00203008
+#define TIMEOUT					2000
+
+struct msp432p4_flash_bank {
+	uint32_t register_base;
+	uint32_t user_bank_size;
+	int dev_id;
+	int probed;
+};
+
+FLASH_BANK_COMMAND_HANDLER(msp432p4_flash_bank_command)
+{
+	struct msp432p4_flash_bank *msp432p4_info;
+
+	if (CMD_ARGC < 6)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	msp432p4_info = malloc(sizeof(struct msp432p4_flash_bank));
+
+	bank->driver_priv = msp432p4_info;
+	msp432p4_info->register_base = bank->base;
+	msp432p4_info->user_bank_size = bank->size;
+	msp432p4_info->dev_id = 9;
+	msp432p4_info->probed = -1;
+
+	return ERROR_OK;
+}
+
+static char *msp432p4_decode_error(uint32_t error_code)
+{
+	switch (error_code) {
+		case FLASH_BUSY:
+			return "FLASH_BUSY";
+		case FLASH_SUCCESS:
+			return "FLASH_SUCCESS";
+		case FLASH_ERROR:
+			return "FLASH_ERROR";
+		case FLASH_TIMEOUT_ERROR:
+			return "FLASH_TIMEOUT_ERROR";
+		case FLASH_VERIFY_ERROR:
+			return "FLASH_VERIFY_WRONG";
+		case FLASH_WRONG_CMD:
+			return "FLASH_WRONG_CMD";
+		case FLASH_PWR_ERR:
+			return "FLASH_PWR_ERR";
+	}
+	return "UNDEFINED";
+}
+
+static int msp432p4_run_algo(struct flash_bank *bank, uint32_t function,
+			uint32_t src_address, uint32_t dst_address,
+			uint32_t src_len)
+{
+	struct target *target = bank->target;
+	struct armv7m_algorithm armv7m_info;
+	struct working_area *write_algorithm;
+	int retval;
+
+	if (target_alloc_working_area(target, sizeof(msp432p4_flash_write_code),
+			&write_algorithm) != ERROR_OK) {
+		LOG_WARNING("no working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	retval = target_write_buffer(target, write_algorithm->address,
+			sizeof(msp432p4_flash_write_code), msp432p4_flash_write_code);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, FLASH_FUNCTION, function);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (src_address > 0) {
+		retval = target_write_u32(target, SRC_ADDRESS, src_address);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	if (function == FLASH_PROGRAM || function == FLASH_SECTOR_ERASE) {
+		retval = target_write_u32(target, DST_ADDRESS, dst_address);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	if (src_len > 0) {
+		retval = target_write_u32(target, SRC_LENGTH, src_len);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.core_mode = ARM_MODE_THREAD;
+
+	retval = target_run_algorithm(target, 0, NULL, 0, NULL,
+				ENTRY_POINT, 0,
+				TIMEOUT, &armv7m_info);
+
+	target_free_working_area(target, write_algorithm);
+
+	return retval;
+}
+
+static int msp432p4_init(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	uint32_t reg_value;
+	char *error_name;
+	int retval;
+
+	retval = target_read_u32(target, DDDS_DEV_ID, &reg_value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = msp432p4_run_algo(bank, FLASH_INIT, 0, 0, 0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_read_u32(target, RETURN_CODE, &reg_value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (reg_value != FLASH_SUCCESS) {
+		error_name = msp432p4_decode_error(reg_value);
+		LOG_ERROR("Cannot init flash controller: %s.", error_name);
+	}
+
+	retval = target_write_u32(target, RETURN_CODE, DEFAULT_CODE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return retval;
+}
+
+static int msp432p4_mass_erase(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	uint32_t reg_value;
+	char *error_name;
+	int retval;
+
+	retval = msp432p4_run_algo(bank, FLASH_MASS_ERASE, 0, 0, 0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_read_u32(target, RETURN_CODE, &reg_value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (reg_value != FLASH_SUCCESS) {
+		error_name = msp432p4_decode_error(reg_value);
+		LOG_ERROR("Cannot mass erase: %s.", error_name);
+	}
+
+	retval = target_write_u32(target, RETURN_CODE, DEFAULT_CODE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return retval;
+}
+
+static int msp432p4_sector_erase(struct flash_bank *bank, uint32_t dst_address)
+{
+	struct target *target = bank->target;
+	uint32_t reg_value;
+	char *error_name;
+	int retval;
+
+	retval = msp432p4_run_algo(bank, FLASH_SECTOR_ERASE, 0, dst_address, 0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_read_u32(target, RETURN_CODE, &reg_value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (reg_value != FLASH_SUCCESS) {
+		error_name = msp432p4_decode_error(reg_value);
+		LOG_ERROR("Cannot erase sector at address: %s.", error_name);
+	}
+
+	retval = target_write_u32(target, RETURN_CODE, DEFAULT_CODE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return retval;
+}
+
+COMMAND_HANDLER(msp432p4_handle_init_command)
+{
+	struct flash_bank *bank;
+	int retval;
+
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return msp432p4_init(bank);
+}
+
+COMMAND_HANDLER(msp432p4_handle_mass_erase_command)
+{
+	struct flash_bank *bank;
+	int retval;
+
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return msp432p4_mass_erase(bank);
+}
+
+COMMAND_HANDLER(msp432p4_handle_erase_sector)
+{
+	struct flash_bank *bank;
+	int retval;
+	uint32_t dst_address;
+
+	if (CMD_ARGC < 2)
+			return ERROR_COMMAND_SYNTAX_ERROR;
+
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (retval != ERROR_OK)
+		return retval;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], dst_address);
+
+	return msp432p4_sector_erase(bank, dst_address);
+}
+
+static const struct command_registration msp432p4_exec_command_handlers[] = {
+	{
+		.name = "mass_erase",
+		.handler = msp432p4_handle_mass_erase_command,
+		.mode = COMMAND_EXEC,
+		.help = "Erase entire flash device.",
+	},
+	{
+		.name = "init",
+		.handler = msp432p4_handle_init_command,
+		.mode = COMMAND_EXEC,
+		.help = "Init flash for operations.",
+	},
+	{
+		.name = "erase_sector",
+		.handler = msp432p4_handle_erase_sector,
+		.mode = COMMAND_EXEC,
+		.help = "Erase a single sector from flash.",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration msp432p4_command_handlers[] = {
+	{
+		.name = "msp432p4",
+		.mode = COMMAND_ANY,
+		.help = "msp432p4 flash command group",
+		.usage = "Set of flashing commands for a msp432p4 target",
+		.chain = msp432p4_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static int msp432p4_erase(struct flash_bank *bank, int first, int last)
+{
+	struct target *target = bank->target;
+	int retval = ERROR_OK, i;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if ((first == 0) && (last == (bank->num_sectors - 1)))
+		return msp432p4_mass_erase(bank);
+
+	for (i = first; i < last; ++i) {
+		retval = msp432p4_sector_erase(bank, bank->sectors[i].offset);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return retval;
+}
+
+static int msp432p4_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	/* Function not required. At startup all sectors are protected.
+	 * Value will be reset at power on. */
+	return ERROR_OK;
+}
+
+static int msp432p4_write(struct flash_bank *bank, const uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct target *target = bank->target;
+	struct working_area *write_algorithm;
+	uint32_t reg_value;
+	char *error_name;
+	struct armv7m_algorithm armv7m_info;
+	int retval = ERROR_OK, size = 0, ofs = 0;
+
+	if (bank->target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* flash write code */
+	if (target_alloc_working_area(target, sizeof(msp432p4_flash_write_code),
+			&write_algorithm) != ERROR_OK) {
+		LOG_WARNING("no working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	};
+
+	retval = target_write_buffer(target, write_algorithm->address,
+			sizeof(msp432p4_flash_write_code), msp432p4_flash_write_code);
+	if (retval != ERROR_OK)
+		return retval;
+
+	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.core_mode = ARM_MODE_THREAD;
+
+	while (count) {
+		if (count > 4096)
+			size = 4096;
+		else
+			size = count;
+
+		retval = target_write_buffer(target, SRC_START, size, buffer + ofs);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Unable to write block write code to target");
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		retval = target_write_u32(target, FLASH_FUNCTION, FLASH_PROGRAM);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = target_write_u32(target, SRC_ADDRESS, SRC_START);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = target_write_u32(target, DST_ADDRESS, ofs);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = target_write_u32(target, SRC_LENGTH, size);
+		if (retval != ERROR_OK)
+			return retval;
+		count -= size;
+		ofs += size;
+
+		retval = target_run_algorithm(target, 0, NULL, 0, NULL,
+					ENTRY_POINT, 0,
+					TIMEOUT, &armv7m_info);
+		if (retval == ERROR_FLASH_OPERATION_FAILED)
+			LOG_ERROR("Cannot flash!");
+
+		retval = target_read_u32(target, RETURN_CODE, &reg_value);
+		if (retval != ERROR_OK)
+			return retval;
+
+		if (reg_value != FLASH_SUCCESS) {
+			error_name = msp432p4_decode_error(reg_value);
+			LOG_ERROR("Cannot write flash program: %s.", error_name);
+		}
+	}
+
+	target_free_working_area(target, write_algorithm);
+
+	return retval;
+}
+
+static int msp432p4_probe(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	struct msp432p4_flash_bank *msp432p4_info = bank->driver_priv;
+	uint32_t reg_value, cpu_id;
+	uint32_t base_address = 0x00;
+	uint32_t flash_size;
+	int retval, i, number_sectors;
+
+	retval = target_read_u32(target, CPU_TYPE, &cpu_id);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (((cpu_id >> 4) & 0xFFF) != 0xC24)
+		return ERROR_FAIL;
+
+	retval = target_read_u32(target, DDDS_DEV_ID, &reg_value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	switch (reg_value & 0xF) {
+		case 0x00:
+			msp432p4_info->dev_id = 0x00;
+			break;
+		case 0x01:
+			msp432p4_info->dev_id = 0x01;
+			break;
+		case 0x02:
+			msp432p4_info->dev_id = 0x02;
+			break;
+		case 0x03:
+			msp432p4_info->dev_id = 0x03;
+			break;
+		case 0x04:
+			msp432p4_info->dev_id = 0x04;
+			break;
+		case 0x05:
+			msp432p4_info->dev_id = 0x05;
+			break;
+		default:
+			return ERROR_FAIL;
+	}
+
+	retval = target_read_u32(target, FLASH_SIZE_REG, &reg_value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	number_sectors = reg_value / 4096;
+	flash_size = reg_value;
+
+	if (bank->sectors) {
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
+	bank->base = base_address;
+	bank->size = flash_size;
+	bank->num_sectors = number_sectors;
+	bank->sectors = malloc(sizeof(struct flash_sector) * number_sectors);
+
+	for (i = 0; i < number_sectors; i++) {
+		bank->sectors[i].offset = i * 4096;
+		bank->sectors[i].size = 4096;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = 1;
+	}
+
+	msp432p4_info->probed = 1;
+
+	retval = msp432p4_init(bank);
+
+	return retval;
+}
+static int msp432p4_auto_probe(struct flash_bank *bank)
+{
+	return ERROR_OK;
+}
+static int msp432p4_protect_check(struct flash_bank *bank)
+{
+	/* Function not required. At startup all sectors are protected. */
+	return ERROR_OK;
+}
+static int get_msp432p4_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	return ERROR_OK;
+}
+
+struct flash_driver msp432p4_flash = {
+	.name = "msp432p4",
+	.commands = msp432p4_command_handlers,
+	.flash_bank_command = msp432p4_flash_bank_command,
+	.erase = msp432p4_erase,
+	.protect = msp432p4_protect,
+	.write = msp432p4_write,
+	.read = default_flash_read,
+	.probe = msp432p4_probe,
+	.auto_probe = msp432p4_auto_probe,
+	.erase_check = default_flash_blank_check,
+	.protect_check = msp432p4_protect_check,
+	.info = get_msp432p4_info,
+};
diff --git a/src/flash/nor/msp432p4.h b/src/flash/nor/msp432p4.h
new file mode 100644
index 0000000..bfcc235
--- /dev/null
+++ b/src/flash/nor/msp432p4.h
@@ -0,0 +1,161 @@
+/***************************************************************************
+ *   Copyright (C) 2014 by Vlad Ungureanu                                  *
+ *   vvu@vdev.ro                                                           *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ ***************************************************************************/
+
+#ifndef MSP432P4_H_
+#define MSP432P4_H_
+
+const uint8_t msp432p4_flash_write_code[] = {
+		0x00, 0x7A, 0x00, 0x20, 0x81, 0x01, 0x00, 0x01, 0x69, 0x06, 0x00, 0x01,
+		0x6B, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01, 0x6D, 0x06, 0x00, 0x01,
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		0x00, 0xF0, 0xD8, 0xB9, 0x70, 0x47, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0xB5, 0x8F, 0x48,
+		0x00, 0x68, 0x00, 0x68, 0x80, 0x47, 0x00, 0xF0, 0x2B, 0xFA, 0x8D, 0x4C,
+		0x01, 0x20, 0x21, 0x1D, 0x08, 0x60, 0x20, 0x68, 0x40, 0x1E, 0x12, 0xD0,
+		0x40, 0x1E, 0x0D, 0xD0, 0x80, 0x1E, 0x08, 0xD0, 0x00, 0x1F, 0x03, 0xD0,
+		0x40, 0xF6, 0xAD, 0x30, 0x08, 0x60, 0x0A, 0xE0, 0x00, 0xF0, 0x0D, 0xF8,
+		0x07, 0xE0, 0x00, 0xF0, 0x72, 0xF8, 0x04, 0xE0, 0x00, 0xF0, 0x4B, 0xF8,
+		0x01, 0xE0, 0x00, 0xF0, 0x2C, 0xF8, 0x00, 0x20, 0x20, 0x60, 0x00, 0xBE,
+		0xFE, 0xE7, 0x70, 0xB5, 0x7C, 0x4D, 0x2D, 0x1D, 0x7C, 0x49, 0x4F, 0xF0,
+		0x80, 0x70, 0x08, 0x60, 0x7B, 0x4C, 0x04, 0xF1, 0x18, 0x00, 0x00, 0x68,
+		0x80, 0x69, 0x01, 0x46, 0x00, 0x20, 0x88, 0x47, 0x06, 0x46, 0x20, 0x68,
+		0x40, 0x6D, 0x02, 0x21, 0x02, 0x46, 0x00, 0x20, 0x90, 0x47, 0x20, 0x68,
+		0x40, 0x6D, 0x02, 0x21, 0x02, 0x46, 0x01, 0x20, 0x90, 0x47, 0x4F, 0xF4,
+		0x40, 0x30, 0x00, 0xF0, 0xCC, 0xF8, 0x01, 0x2E, 0x01, 0xD0, 0x6F, 0x48,
+		0x01, 0xE0, 0x40, 0xF6, 0xCE, 0x20, 0x28, 0x60, 0x70, 0xBD, 0xF8, 0xB5,
+		0x68, 0x4C, 0x24, 0x1D, 0x00, 0x27, 0x00, 0xF0, 0x59, 0xF8, 0x05, 0x25,
+		0x67, 0x4E, 0x06, 0xE0, 0x30, 0x68, 0x00, 0x6A, 0x01, 0x46, 0x01, 0x20,
+		0x88, 0x47, 0x07, 0x46, 0x6D, 0x1E, 0x0F, 0xB9, 0x00, 0x2D, 0xF5, 0xDC,
+		0x15, 0xB1, 0x40, 0xF6, 0xCE, 0x20, 0x00, 0xE0, 0x61, 0x48, 0x20, 0x60,
+		0x00, 0xF0, 0x8A, 0xF8, 0xF8, 0xBD, 0x2D, 0xE9, 0xF0, 0x41, 0x5A, 0x48,
+		0x00, 0xF1, 0x14, 0x06, 0x00, 0xF1, 0x04, 0x08, 0x00, 0x25, 0x00, 0xF0,
+		0x60, 0xF8, 0x05, 0x24, 0x57, 0x4F, 0x07, 0xE0, 0x38, 0x68, 0x41, 0x6A,
+		0x30, 0x68, 0x0A, 0x46, 0x01, 0x21, 0x90, 0x47, 0x05, 0x46, 0x64, 0x1E,
+		0x0D, 0xB9, 0x00, 0x2C, 0xF4, 0xDC, 0x14, 0xB1, 0x40, 0xF6, 0xCE, 0x20,
+		0x01, 0xE0, 0x4D, 0xF6, 0xAD, 0x60, 0xC8, 0xF8, 0x00, 0x00, 0x00, 0xF0,
+		0x67, 0xF8, 0xBD, 0xE8, 0xF0, 0x81, 0x38, 0xB5, 0x48, 0x4C, 0x25, 0x1D,
+		0x00, 0xF0, 0x41, 0xF8, 0x48, 0x48, 0x00, 0x68, 0x83, 0x6A, 0x04, 0xF1,
+		0x14, 0x01, 0x09, 0x68, 0x04, 0xF1, 0x10, 0x00, 0x00, 0x68, 0x18, 0x34,
+		0x22, 0x68, 0x1C, 0x46, 0x01, 0x23, 0xA0, 0x47, 0x04, 0x46, 0x00, 0xF0,
+		0x4F, 0xF8, 0x01, 0x2C, 0x02, 0xD0, 0x4D, 0xF6, 0xAD, 0x60, 0x01, 0xE0,
+		0x40, 0xF6, 0xCE, 0x20, 0x28, 0x60, 0x38, 0xBD, 0x38, 0xB5, 0x3E, 0x4D,
+		0x3A, 0x4C, 0x28, 0x68, 0x40, 0x08, 0x0E, 0xD3, 0x20, 0x68, 0x00, 0x69,
+		0x4F, 0xF0, 0xFF, 0x31, 0x02, 0x46, 0x01, 0x20, 0x90, 0x47, 0x20, 0x46,
+		0x00, 0x68, 0x00, 0x69, 0x4F, 0xF0, 0xFF, 0x31, 0x02, 0x46, 0x02, 0x20,
+		0x90, 0x47, 0x28, 0x68, 0x80, 0x08, 0x0D, 0xD3, 0x20, 0x68, 0x00, 0x69,
+		0x4F, 0xF0, 0xFF, 0x31, 0x02, 0x46, 0x03, 0x20, 0x90, 0x47, 0x20, 0x68,
+		0x00, 0x69, 0x4F, 0xF0, 0xFF, 0x31, 0x02, 0x46, 0x04, 0x20, 0x90, 0x47,
+		0x38, 0xBD, 0x10, 0xB5, 0x27, 0x4C, 0x20, 0x68, 0x00, 0x69, 0x4F, 0xF0,
+		0xFF, 0x31, 0x02, 0x46, 0x01, 0x20, 0x90, 0x47, 0x20, 0x68, 0x00, 0x69,
+		0x4F, 0xF0, 0xFF, 0x31, 0x02, 0x46, 0x02, 0x20, 0x90, 0x47, 0x20, 0x68,
+		0x00, 0x69, 0x4F, 0xF0, 0xFF, 0x31, 0x02, 0x46, 0x03, 0x20, 0x90, 0x47,
+		0x20, 0x68, 0x00, 0x69, 0x4F, 0xF0, 0xFF, 0x31, 0x02, 0x46, 0x04, 0x20,
+		0x90, 0x47, 0x10, 0xBD, 0x10, 0xB5, 0x18, 0x4C, 0x20, 0x68, 0x40, 0x69,
+		0x4F, 0xF0, 0xFF, 0x31, 0x02, 0x46, 0x01, 0x20, 0x90, 0x47, 0x20, 0x68,
+		0x40, 0x69, 0x4F, 0xF0, 0xFF, 0x31, 0x02, 0x46, 0x02, 0x20, 0x90, 0x47,
+		0x20, 0x68, 0x40, 0x69, 0x4F, 0xF0, 0xFF, 0x31, 0x02, 0x46, 0x03, 0x20,
+		0x90, 0x47, 0x20, 0x68, 0x40, 0x69, 0x4F, 0xF0, 0xFF, 0x31, 0x02, 0x46,
+		0x04, 0x20, 0x90, 0x47, 0x10, 0xBD, 0x0D, 0x4B, 0x46, 0xF6, 0x5A, 0x11,
+		0x19, 0x60, 0x0C, 0x4A, 0x11, 0x68, 0x21, 0xF4, 0xE0, 0x21, 0x08, 0x43,
+		0x10, 0x60, 0x00, 0x20, 0x18, 0x60, 0x70, 0x47, 0x64, 0x08, 0x00, 0x02,
+		0x50, 0x01, 0x00, 0x20, 0x08, 0xED, 0x00, 0xE0, 0x1C, 0x08, 0x00, 0x02,
+		0x00, 0xAD, 0xDE, 0x00, 0xAD, 0xDE, 0xAD, 0xDE, 0x6C, 0x01, 0x00, 0x20,
+		0x00, 0x04, 0x01, 0x40, 0x04, 0x04, 0x01, 0x40, 0x00, 0x2A, 0x4A, 0xD0,
+		0x5F, 0xEA, 0x00, 0x0C, 0x8B, 0x07, 0x1C, 0xD1, 0x83, 0x07, 0x22, 0xD1,
+		0x10, 0x2A, 0x08, 0xD3, 0x70, 0xB4, 0x10, 0x3A, 0x78, 0xC9, 0x78, 0xC0,
+		0x10, 0x3A, 0xFB, 0xD2, 0x70, 0xBC, 0x10, 0x32, 0x38, 0xD0, 0x04, 0x2A,
+		0x2C, 0xD3, 0x08, 0x2A, 0x05, 0xD3, 0x0C, 0x2A, 0x24, 0xBF, 0x08, 0xC9,
+		0x08, 0xC0, 0x08, 0xC9, 0x08, 0xC0, 0x08, 0xC9, 0x08, 0xC0, 0x92, 0x07,
+		0x2A, 0xD0, 0x92, 0x0F, 0x22, 0xE0, 0x0B, 0x78, 0x03, 0x70, 0x49, 0x1C,
+		0x40, 0x1C, 0x52, 0x1E, 0x22, 0xD0, 0x8B, 0x07, 0xF7, 0xD1, 0xC3, 0x07,
+		0x14, 0xD1, 0x83, 0x07, 0xD8, 0xD0, 0x12, 0x1F, 0x12, 0xD3, 0x08, 0xC9,
+		0x03, 0x80, 0x1B, 0x0C, 0x43, 0x80, 0x00, 0x1D, 0x12, 0x1F, 0xF8, 0xD2,
+		0x0A, 0xE0, 0x08, 0xC9, 0x03, 0x70, 0x1B, 0x0A, 0x43, 0x70, 0x1B, 0x0A,
+		0x83, 0x70, 0x1B, 0x0A, 0xC3, 0x70, 0x00, 0x1D, 0x12, 0x1F, 0xF4, 0xD2,
+		0x12, 0x1D, 0x05, 0xD0, 0x0B, 0x78, 0x03, 0x70, 0x49, 0x1C, 0x40, 0x1C,
+		0x52, 0x1E, 0xF9, 0xD1, 0x60, 0x46, 0x70, 0x47, 0xF0, 0xB5, 0x1E, 0x48,
+		0x01, 0x27, 0xF8, 0x42, 0x01, 0xD0, 0x00, 0xF0, 0x67, 0xF8, 0x1E, 0x4D,
+		0x1E, 0x4F, 0x1F, 0x4E, 0xBD, 0x42, 0x06, 0xD2, 0x03, 0xCD, 0x04, 0x78,
+		0xA4, 0x00, 0x34, 0x59, 0x40, 0x1C, 0xA0, 0x47, 0xF6, 0xE7, 0x16, 0x4D,
+		0x16, 0x4F, 0xBD, 0x42, 0x02, 0xD2, 0x10, 0xCD, 0xA0, 0x47, 0xFA, 0xE7,
+		0xF0, 0xBD, 0x03, 0x25, 0x1B, 0xE0, 0x41, 0x68, 0x08, 0x30, 0x0A, 0x1C,
+		0x2A, 0x40, 0x0B, 0xD1, 0x1A, 0x1C, 0x2A, 0x40, 0xAB, 0x43, 0x05, 0xD0,
+		0x04, 0x68, 0x04, 0x30, 0x0C, 0x60, 0x04, 0x31, 0x04, 0x3B, 0xF9, 0xD1,
+		0x13, 0x1C, 0x05, 0xD0, 0x04, 0x78, 0x01, 0x30, 0x0C, 0x70, 0x01, 0x31,
+		0x01, 0x3B, 0xF9, 0xD1, 0x02, 0x1C, 0x2A, 0x40, 0x01, 0xD0, 0xA8, 0x43,
+		0x04, 0x30, 0x03, 0x68, 0x00, 0x2B, 0xE0, 0xD1, 0x70, 0x47, 0xC0, 0x46,
+		0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x4E, 0xF6, 0x88, 0x51, 0xCE, 0xF2, 0x00, 0x01, 0x08, 0x68, 0x4F, 0xF0,
+		0xF0, 0x03, 0x40, 0xEA, 0x03, 0x40, 0x08, 0x60, 0x09, 0x48, 0x85, 0x46,
+		0x09, 0x48, 0x85, 0x44, 0x6F, 0x46, 0x07, 0x20, 0x87, 0x43, 0xBD, 0x46,
+		0x07, 0x48, 0x6F, 0x46, 0x07, 0x60, 0xFF, 0xF7, 0x9F, 0xFF, 0x00, 0xF0,
+		0x6B, 0xF8, 0x01, 0x20, 0x00, 0xF0, 0x30, 0xF8, 0xFE, 0xE7, 0xC0, 0x46,
+		0x00, 0x78, 0x00, 0x20, 0x00, 0x02, 0x00, 0x00, 0x80, 0x06, 0x00, 0x01,
+		0x70, 0xB5, 0x0F, 0x4D, 0x06, 0x46, 0x73, 0x88, 0x00, 0x24, 0x16, 0xE0,
+		0xA0, 0x00, 0x00, 0xEB, 0xC4, 0x00, 0x30, 0x18, 0x41, 0x68, 0xC2, 0x68,
+		0x80, 0x68, 0x4A, 0xB9, 0x2A, 0x68, 0x52, 0xB1, 0x0A, 0x78, 0x55, 0xF8,
+		0x22, 0x30, 0x4A, 0x1C, 0x01, 0x46, 0x10, 0x46, 0x98, 0x47, 0x01, 0xE0,
+		0xFF, 0xF7, 0x2A, 0xFF, 0x73, 0x88, 0x64, 0x1C, 0xA4, 0xB2, 0xA3, 0x42,
+		0xE6, 0xDC, 0x70, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBF, 0x70, 0x47,
+		0x08, 0xB5, 0xFF, 0xF7, 0xFB, 0xFF, 0xFE, 0xE7, 0x38, 0xB5, 0x05, 0x46,
+		0x09, 0x48, 0x00, 0x68, 0x80, 0x47, 0x09, 0x4C, 0x20, 0x1D, 0x00, 0x68,
+		0x10, 0xB1, 0x01, 0x46, 0x28, 0x46, 0x88, 0x47, 0x20, 0x68, 0x00, 0xB1,
+		0x80, 0x47, 0x05, 0x48, 0x00, 0x68, 0x80, 0x47, 0xFF, 0xF7, 0xE8, 0xFF,
+		0x38, 0xBD, 0xC0, 0x46, 0x70, 0x06, 0x00, 0x01, 0x78, 0x06, 0x00, 0x01,
+		0x74, 0x06, 0x00, 0x01, 0xEF, 0xF3, 0x10, 0x80, 0x72, 0xB6, 0x70, 0x47,
+		0x00, 0x20, 0x70, 0x47, 0xEF, 0xF3, 0x10, 0x80, 0x70, 0x47, 0x00, 0x20,
+		0x70, 0x47, 0xEF, 0xF3, 0x10, 0x80, 0x62, 0xB6, 0x70, 0x47, 0x00, 0x20,
+		0x70, 0x47, 0x30, 0xBF, 0x70, 0x47, 0x80, 0xF3, 0x11, 0x88, 0x70, 0x47,
+		0xEF, 0xF3, 0x11, 0x80, 0x70, 0x47, 0x00, 0x20, 0x70, 0x47, 0x00, 0x00,
+		0x04, 0x49, 0xB1, 0xF1, 0xFF, 0x3F, 0x07, 0xBF, 0x00, 0x21, 0x08, 0x1C,
+		0x08, 0x68, 0x09, 0x1D, 0xFF, 0xF7, 0xA8, 0xBD, 0xFF, 0xFF, 0xFF, 0xFF,
+		0x03, 0x49, 0x08, 0x60, 0x70, 0x47, 0x02, 0x49, 0x09, 0x1F, 0x08, 0x60,
+		0x70, 0x47, 0x70, 0x47, 0x74, 0x06, 0x00, 0x01, 0xFE, 0xE7, 0xFE, 0xE7,
+		0xFF, 0xF7, 0xCA, 0xBF, 0x63, 0x06, 0x00, 0x01, 0x63, 0x06, 0x00, 0x01,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+#endif /* MSP432P4_H_ */
diff --git a/tcl/target/msp432p401r.cfg b/tcl/target/msp432p401r.cfg
new file mode 100644
index 0000000..b20e057
--- /dev/null
+++ b/tcl/target/msp432p401r.cfg
@@ -0,0 +1,52 @@
+######################################
+# Target:    MSP432P401R
+######################################
+
+adapter_khz 100
+
+if { [info exists CHIPNAME] } {
+   set _CHIPNAME $CHIPNAME
+} else {
+   set _CHIPNAME msp432p401r
+}
+
+if { [info exists ENDIAN] } {
+   set _ENDIAN $ENDIAN
+} else {
+   set _ENDIAN little
+}
+
+# Work-area is a space in RAM used for flash programming
+if { [info exists WORKAREASIZE] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x00003000
+}
+
+# mychip core
+if { [info exists CPUTAPID] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x4ba00477
+}
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m -endian $_ENDIAN -chain-position $_TARGETNAME
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME msp432p4 0x00 0 0 0 $_TARGETNAME
+
+cortex_m reset_config sysresetreq
+init
+reset halt
+
+
+# To flash:
+#msp432 init 0
+#msp432 mass_erase 0
+#msp432 init 0
+#flash write_image /your/image/here.bin
+#reset run
